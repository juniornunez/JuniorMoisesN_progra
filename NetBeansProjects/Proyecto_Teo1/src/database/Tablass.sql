--TABLAS CON SUS ATRIBUTOS
create table USUARIOS 
(

    Id_usuario bigint generated by default as identity (start with 1, increment by 1)primary key,
    Nombre_usuario varchar(70)not null,
    Apellido_usuario varchar(70)not null,
    Correo_electronico varchar(70)not null unique,
    Fecha_Registro timestamp not null,
    Salario_mensual_base decimal(14,2)not null, -- es 14,2 para controlar bien los montos
    Estado_usuario boolean default true,
    creado_en timestamp default current_timestamp,
    modificado_en timestamp,
    creado_por varchar(100) default 'system',
    modificado_por varchar(100)

);

create table PRESUPUESTO
(

    Id_presupuesto bigint generated by default as identity(start with 1, increment by 1) primary key,
    Id_usuario bigint not null,
    Nombre_descriptivo varchar(500)not null,
    Anio_de_inicio smallint not null,
    Mes_de_inicio tinyint not null, -- 1...12
    Anio_de_fin smallint not null,
    Mes_de_fin tinyint not null,
    Total_de_ingresos decimal(14,2)not null,
    Total_de_gastos decimal(14,2)not null,
    Total_de_ahorro decimal(14,2)not null,
    Fecha_hora_creacion timestamp not null,
    Estado_presupuesto varchar(20)not null,
    creado_en timestamp default current_timestamp,
    modificado_en timestamp,
    creado_por varchar(100) default 'system',
    modificado_por varchar(100)

);

create table CATEGORIA
(

    Id_categoria bigint generated by default as identity(start with 1, increment by 1) primary key,
    Nombre varchar(50) not null,
    Descripcion_detallada varchar(500),
    Tipo_de_categoria varchar(15) not null, --ingreso|gasto|ahorro
    creado_en timestamp default current_timestamp,
    modificado_en timestamp,
    creado_por varchar(100) default 'system',
    modificado_por varchar(100)

);

create table SUBCATEGORIA
(

    Id_subcategoria bigint generated by default as identity(start with 1, increment by 1) primary key,
    Id_categoria bigint not null,
    Nombre_subcategoria varchar(70)not null,
    Descripcion_detallada varchar(500)not null,
    Estado boolean default true not null,
    Por_defecto boolean default false not null,
    creado_en timestamp default current_timestamp,
    modificado_en timestamp,
    creado_por varchar(100) default 'system',
    modificado_por varchar(100)

);

--con esta restriccion se evita nombres dupliados de subcategoria por categoria (mejora de calidad de datos)
create unique index ux_subcat_nombre_por_categoria
    on SUBCATEGORIA(Id_categoria, Nombre_subcategoria);

create table PRESUPUESTO_DETALLE
(

    Id_presupuesto_detalle bigint generated by default as identity(start with 1, increment by 1) primary key,
    Id_presupuesto bigint not null,
    Id_subcategoria bigint not null,
    Monto_mensual decimal(14,2) not null,
    Justificacion_del_monto varchar(500),
    creado_en timestamp default current_timestamp,
    modificado_en timestamp,
    creado_por varchar(100) default 'system',
    modificado_por varchar(100)

);

-- para evitar que se duplique la misma subcategoria en un presupuesto
create unique index presupuesto_unico
    on PRESUPUESTO_DETALLE (Id_presupuesto, Id_subcategoria);

create table OBLIGACION_FIJA
(

    Id_obligacion_fija bigint generated by default as identity(start with 1, increment by 1) primary key,
    Id_usuario bigint not null,
    Id_subcategoria bigint not null, --en obligacion fija la subcategoria siempre es de tipo gasto
    Nombre varchar(70) not null,
    Descripcion_detallada varchar(500)not null,
    Monto_fijo_mensual decimal(14,2)not null,
    Dia_del_mes_de_vencimiento smallint not null, -- 1...31
    Esta_vigente boolean default true not null,
    Fecha_inicio_de_la_obligacion date not null,
    Fecha_de_finalizacion date,
    creado_en timestamp default current_timestamp,
    modificado_en timestamp,
    creado_por varchar(100) default 'system',
    modificado_por varchar(100)

);

create table TRANSACCION
(

    Id_transaccion bigint generated by default as identity(start with 1, increment by 1) primary key,
    Id_usuario bigint not null,
    Id_presupuesto bigint not null,
    Anio smallint not null,
    Mes smallint not null,
    Id_subcategoria bigint not null,
    Id_obligacion_fija bigint, --opcional
    Tipo_de_transaccion varchar(15)not null, --ingreso|gasto|ahorro
    Descripcion varchar(500),
    Monto decimal(14,2)not null,
    Fecha date not null,
    Metodo_de_pago varchar(30)not null, --efectivo|tarjeta_debito|tarjeta_credito|transferencia
    Fecha_hora_de_registro timestamp not null,
    creado_en timestamp default current_timestamp,
    modificado_en timestamp,
    creado_por varchar(100) default 'system',
    modificado_por varchar(100)

);

/*
Que es un indice?
Es una estructura (normalmente B-tree) que acelera busquedas, joins, validaciones de FKs y 
ordenamientos sobre una o varias columnas.
Sin indice: la BD revisa muchas filas (table scan).
Con indice: salta directo a las filas candidatas (como un indice de libro).

Indices me serviran para acelerar las consultas que filtran por periodo y por presupuesto o subcategoria.
Funcionaran porque el motor puede localizar rapido los registros de transaccion usando el orden de las columnas
del indice.

Optimiza consultas que fijan un presupuesto y luego filtran/ordenan por año/mes.
Optimiza consultas que fijan una subcategoría y filtran/ordenan por año/mes.

ON: significa "crealo sobre esta tabla y estas columnas".
No es el ON de los JOIN (aunque la palabra sea la misma).
*/
create index presu_periodo on TRANSACCION(Id_presupuesto,Anio,Mes);
create index subcat_periodo on TRANSACCION(Id_subcategoria,Anio,Mes);

create table META_AHORRO
(
    Id_Ahorro bigint generated by default as identity(start with 1, increment by 1) primary key,
    Id_usuario bigint not null,
    Id_subcategoria bigint not null,--de tipo ahorro
    Nombre varchar(70)not null,
    Descripcion_detallada varchar(500),
    Monto_total_alcanzar decimal(14,2)not null,
    Monto_ahorrado decimal(14,2)not null,
    Fecha_inicio date not null,
    Fecha_objetivo date not null,
    Prioridad varchar(10)not null,--alta|media|baja
    Estado varchar(10)not null,--en_progreso|completada|cancelada|pausada
    creado_en timestamp default current_timestamp,
    modificado_en timestamp,
    creado_por varchar(100) default 'system',
    modificado_por varchar(100)
    
);


--RELACIONES
alter table PRESUPUESTO add constraint fk_presupuesto_usuario foreign key(Id_usuario)references USUARIOS(Id_usuario);

alter table META_AHORRO add constraint fk_meta_usuario foreign key(Id_usuario)references USUARIOS(Id_usuario);

alter table OBLIGACION_FIJA add constraint fk_obligacion_usuario foreign key(Id_usuario)references USUARIOS(Id_usuario);

alter table TRANSACCION add constraint fk_transaccion_usuario foreign key(Id_usuario)references USUARIOS(Id_usuario);

alter table SUBCATEGORIA add constraint fk_subcat_categoria foreign key(Id_categoria)references CATEGORIA(Id_categoria);

alter table PRESUPUESTO_DETALLE add constraint fk_pdet_presupuesto foreign key(Id_presupuesto)references PRESUPUESTO(Id_presupuesto);

alter table PRESUPUESTO_DETALLE add constraint fk_presupuesto_subcategoria foreign key(Id_subcategoria)references SUBCATEGORIA(Id_subcategoria);

--se asegura que el lado de obligacion fija tiene 1 subcategoria 
alter table OBLIGACION_FIJA add constraint fk_obligacion_subcategoria foreign key(Id_subcategoria)references SUBCATEGORIA(Id_subcategoria);

--relacion 1:1 OBLIGACION_FIJA <-> SUBCATEGORIA
alter table OBLIGACION_FIJA add constraint uq_obligacion_subcategoria unique(Id_subcategoria);

alter table TRANSACCION add constraint fk_transaccion_de_subcategoria foreign key(Id_subcategoria)references SUBCATEGORIA(Id_subcategoria);

alter table META_AHORRO add constraint fk_meta_subcategoria foreign key(Id_subcategoria)references SUBCATEGORIA(Id_subcategoria);

alter table TRANSACCION add constraint fk_transaccion_presupuesto foreign key(Id_presupuesto)references PRESUPUESTO(Id_presupuesto);

alter table TRANSACCION add constraint fk_transaccion_obligacion foreign key(Id_obligacion_fija)references OBLIGACION_FIJA(Id_obligacion_fija);

--RESTRICCIONES

/*
Usare "check" para cumplir reglas logicas que deben cumplirse para cada fila y columna.
Si la condicion no se cumple, el INSERT/UPDATE falla con error.

Tambien usare "between", es un operador para decir "entre A y B incluyendo los extremos".
Lo usare para los meses 1..12 y para los dias 1..31.
*/
alter table TRANSACCION add constraint ck_mes check(Mes between 1 and 12);

alter table OBLIGACION_FIJA add constraint ck_dia check(Dia_del_mes_de_vencimiento between 1 and 31);

--restriccion para no poner los montos en negativo
alter table TRANSACCION add constraint ck_monto_no_negativo_transaccion check(Monto>=0);

--Monto mensual no negativo en PRESUPUESTO_DETALLE
alter table PRESUPUESTO_DETALLE add constraint ck_monto_no_negativo_presupuesto_detalle check(Monto_mensual>=0);

--Tipo de transaccion valido
alter table TRANSACCION add constraint ck_tipo_valido_transaccion check(Tipo_de_transaccion in ('ingreso','gasto','ahorro'));

alter table CATEGORIA add constraint ck_tipo_categoria check(Tipo_de_categoria in('ingreso','gasto','ahorro'));

--metodo de pago valido
alter table TRANSACCION add constraint ck_metodo_pago_valido check(Metodo_de_pago in ('efectivo','tarjeta_debito','tarjeta_credito','transferencia'));

--prioridad y estado de meta_ahorro
alter table META_AHORRO add constraint ck_meta_prioridad check(Prioridad in('alta','media','baja'));

--progreso de las metas
alter table META_AHORRO add constraint ck_metas_estado check(Estado in('en_progreso','completada','cancelada','pausada'));

--estado del presupuesto 
alter table PRESUPUESTO add constraint ck_estado_presupuesto check(Estado_presupuesto in('activo','cerrado','borrador'));

--para el mes de inicio que sea valido 1....12
alter table PRESUPUESTO add constraint ck_mes_de_inicio check(Mes_de_inicio between 1 and 12);

alter table PRESUPUESTO add constraint ck_mes_de_fin check(Mes_de_fin between 1 and 12);

/*
Esta restriccion evita los periodos al reves. Solo permite:  
Caso A: el año de fin es mayor que el de inicio
Caso B: si el año de fin es igual, entonces el mes de fin >= mes de inicio
Esto quiere decir que el final debe estar despues o igual que el inicio dentro del mismo año.
*/
alter table PRESUPUESTO
    add constraint ck_presu_vigencia
        check (
            (Anio_de_fin > Anio_de_inicio)
            or (Anio_de_fin = Anio_de_inicio and Mes_de_fin >= Mes_de_inicio)
        );



